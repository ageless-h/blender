# M2 - 统一的终端抽象层（为多后端做铺垫）

对应：`PLAN.md` -> `### M2 - 统一的终端抽象层`

## 阶段目标

- 定义一个稳定的“会话/后端”抽象，使得新增后端（shell/ai）尽量不触及绘制与编辑核心逻辑。
- 让现有 Python Console 成为该抽象的参考实现。

## 输入/前置条件

- M1 的行为规则已相对稳定（尤其是多行/粘贴/执行策略）。

## 交付物（阶段级）

- 终端抽象接口与一个参考实现
- Python Console 后端适配完成

## To-Do

### 1. 定义“会话/后端”抽象（文档 + 最小接口）

- [ ] **任务说明**：先以文档形式定义最小接口（输入/输出/prompt/生命周期/状态）。

#### 交付物

- 一份接口文档（建议包含伪代码/接口签名），至少描述：
  - 输入：单行/多行、raw/tty 需求
  - 输出：stdout/stderr/info、可选元数据（timestamp/group id）
  - Prompt：静态/动态（cwd 等）
  - 生命周期：create/close/reset
  - 状态：cwd/env/encoding

#### 交付检查

- 文档必须回答：
  - Blender 中“一个会话”的归属：Region/Space/Window？
  - 会话在 UI 关闭/重开时是否复用？
  - 输出如何映射到 `scrollback_append`（频率/节流/批量）

#### 测试/验收

- **设计验收**：模拟新增 `shell` 后端时，明确哪些文件需要改、哪些不需要改。

---

### 2. 确定落点层级（Python 抽象 vs C++ 抽象）

- [ ] **任务说明**：决策先落在 Python 还是 C++，并写出原因与迁移路径。

#### 交付物

- 决策记录：
  - 方案 A：延续 `_console_<language>` 模块机制，在 Python 层抽象
  - 方案 B：在 C++/Editor 层引入后端接口

#### 交付检查

- 决策需包含：
  - 对性能与并发的影响
  - 对改动范围与维护成本的影响
  - 对 M3（shell）与 M4（ai）的影响

#### 测试/验收

- **可落地性检查**：列出“最小实现”所需改动文件清单。

---

### 3. 最小重构：把现有 Python Console 适配到抽象层

- [ ] **任务说明**：在不破坏现有行为的前提下，让 Python Console 通过抽象层运行。

#### 交付物

- Python Console 适配代码
- 文档：
  - session 策略（Region vs Space）
  - 持久化策略（切换 UI、重载、撤销等）

#### 交付检查

- M0/M1 的手工测试用例应全部通过（或明确记录变化）。

#### 测试/验收

- **回归测试（手工）**：执行 M0/M1 清单。
- **稳定性**：连续执行 100 次简单命令不崩溃、不泄漏（至少做手工压力测试记录）。

---

### 4. 验收：新增后端不需要改动绘制/编辑核心逻辑

- [ ] **任务说明**：用一个“最小 mock 后端”来验证抽象层目标。

#### 交付物

- 一个 mock 后端（例如把输入回显为输出），作为示例。

#### 测试/验收

- 仅新增后端实现 + 少量 glue，即可在 UI 中切换并工作。
